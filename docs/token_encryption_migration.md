# 凭证加密密钥治理与迁移指南

## 背景

`TOKEN_ENCRYPTION_KEY` 用于对磁盘上的 Google OAuth 凭证执行静态加密。启用密钥后，所有新增或刷新生成的凭证均以加密形式写入，并通过原子重命名保证写入安全。本指南帮助运维团队规划密钥的生成、分发、轮换及历史凭证迁移。

## 1. 密钥生成与存储

1. 使用密码学安全的随机源生成至少 32 字节的原始密钥（例如 `openssl rand -base64 32`）。
2. 将生成的密钥作为环境变量 `TOKEN_ENCRYPTION_KEY` 注入 Bot 运行环境，或存放于企业密钥管理服务（KMS）并在启动脚本中安全下发。
3. 禁止将密钥写入代码仓库、CI 日志或聊天工具；如需持久化，务必启用密钥库审计与访问控制。
4. 在多实例部署中，确保所有实例使用同一密钥，以支持任意节点读取由其它节点写入的凭证。

## 2. 首次启用步骤

1. 在预生产环境设置 `TOKEN_ENCRYPTION_KEY` 并启动 Bot，确认凭证写入与读取流程均正常。
2. 部署到生产前，备份 `user_data/` 目录，以便回滚。
3. 启用密钥后，新的凭证会自动以密文存储；历史明文凭证会在下次刷新或重新授权时自动迁移。
4. 若历史凭证需要立即迁移，可触发一次凭证刷新任务或引导用户执行 `/auth` 重新授权。

## 3. 密钥轮换策略

1. 准备新密钥并在所有节点写入备用环境变量（例如 `TOKEN_ENCRYPTION_KEY_NEXT`）。
2. 选择维护窗口，逐节点更新 `TOKEN_ENCRYPTION_KEY` 并重启服务，确保所有实例都使用新密钥。
3. 旧密钥加密的凭证会在下一次刷新时重新写入新密钥；在过渡期间，TokenStore 会检测到解密失败并将旧文件隔离。
4. 监控日志中的 `token_event=decrypt_failed` 或 `token_event=missing_key` 字段，确认是否存在仍使用旧密钥的凭证，并根据日志中的脱敏 ID 通知对应用户重新授权。
5. 完成轮换后，安全销毁旧密钥并更新应急预案文档。

## 4. 故障排查与恢复

| 场景 | 现象 | 处理建议 |
| --- | --- | --- |
| 未配置密钥但遇到加密文件 | TokenStore 抛出 `MissingTokenEncryptionKeyError`，日志包含 `token_event=missing_key`，原文件被转移至 `user_data/quarantine/` | 为所有实例配置正确的 `TOKEN_ENCRYPTION_KEY`，或手动解密历史凭证后重新授权 |
| 密钥配置错误 | 日志出现 `token_event=decrypt_failed`，凭证被隔离 | 校正密钥并重启服务，若用户仍受影响，指导其执行 `/auth` |
| 凭证文件损坏 | 日志包含 `token_event=load_error` 或 `invalid_credentials`，文件进入隔离目录 | 删除隔离文件并提醒用户重新授权 |

## 5. 审计与可观测性

- 所有与凭证相关的日志均使用 `masked_user_id`、`masked_token_path` 等字段进行脱敏，可放心收集到集中式日志平台。
- 通过 `token_event` 字段快速筛查故障类别，例如 `refresh_failed`、`quarantine_*`、`missing_key` 等。
- 建议在监控系统中创建告警规则，及时捕获 `missing_key` 与 `decrypt_failed` 事件。

## 6. 回滚方案

1. 删除或清空 `TOKEN_ENCRYPTION_KEY` 后重启服务，TokenStore 会恢复明文模式，并在日志中输出降级警告。
2. 对于仍处于密文的文件，可利用旧密钥执行离线解密，或指导用户重新授权生成新的明文凭证。
3. 回滚完成后，更新文档并记录事件原因，确保未来再次启用加密前补足缺陷。

通过以上步骤，可在不暴露敏感信息的前提下安全地启用、轮换与回滚凭证加密能力，为多实例部署和长期运维提供可靠支撑。
